# -*- coding: utf-8 -*-
"""leetcode_practive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dxRN5wX_VgkOwWezVJS5XFJ27XU_C9G_
"""

import numpy as np




"""#136. Single Number

Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
"""

#

class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """    
        i = 0  # pointer for the current element 
        r = []
        # single = nums [0]    
        while  i <len(nums):     
            num = nums[i]
            if num not in r :  # single
                r.append(num)
            else:   # double
                r.remove(num)        
            i+=1
        if len(r)==1 :
            return r[0]
        else:
            return None

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
    
class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
       
        if l1 ==None :
            return l2
        elif l2 == None:
            return l1
        else:
            l = ListNode(None)   
            while l1 != None and l2 != None:
                l.next = l1 if l1.val < l2.val else l2.val
                if l1.val < l2.val:
                    l1 = l1.next
                else:
                    l2 = l2.next
            return l.next

"""# 146. LRU Cache

https://leetcode.com/problems/lru-cache/
"""

class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.keys = []
        self.values = []
        self.capacity = capacity
        self.least_used_key = None 


    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        print ("Get",key)

        if key in self.keys :
            return key
        else:
            return -1        

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if self.get(key) ==-1:
            if len(self.keys) +1 > self.capacity:
                self.least_used_key = self.keys
                self.keys.pop(-1)
                self.values.pop(-1)      
            if  self.get(key) ==-1:                
                self.keys.append(key)
                self.values.append(value)
        print ("Put",key, "Updated keys=",self.keys)
            
# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

cache =LRUCache( 2  );

print(cache.put(1, 1))
print(cache.put(2, 2))
print(cache.get(1))       #// returns 1
print(cache.put(3, 3))    #// evicts key 2
print(cache.get(2))      #// returns -1 (not found)
print(cache.put(4, 4))  # // evicts key 1
print(cache.get(1))       #// returns -1 (not found)
print(cache.get(3))       #// returns 3
print(cache.get(4))      # // returns 4

"""56. Merge Intervals

https://leetcode.com/problems/merge-intervals/
"""

#@title

class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """      
        self.interval_len = len(intervals)      
        interval_deltas = 1
        while interval_deltas != 0 :
            new_merged = self.merge_intervals(intervals)            
            interval_deltas = self.interval_len- len(new_merged)
            intervals = new_merged        
            self.interval_len = len(intervals) 
            
        result = intervals
        return result

    def merge_interval_pair (self,i,j):
        if min(i) > min(j):  # make sure i is the smaller one
            i, j = j , i
        # merge
        if max(i) < min(j) :
            return  [i,j]
        else:
            return [[ min( min(i),min(j)),max(max(j),max(i))]]

    def merge_intervals (self,intervals):        
        # print ("intervals=",intervals)
        its = intervals
        if len(its) <=1:
            r = its            
        else:    
            r = []
            pi = 0
            it_ids = [i for i in range(len(intervals))]            
            while pi in it_ids:                
                i = its[pi]                             # pointer pi for interval i 
                pj = pi+1
                while pj in it_ids and pi in it_ids:    # pointer pj for interval j , pi might be deleted
                    j = its[pj]      
                    checked_its = self.merge_interval_pair (i,j)  
                    if len(checked_its) == 1:
                        it_ids.remove(pi)
                        it_ids.remove(pj)    
                        its.remove(i)
                        its.remove(j)
                        its.append(checked_its[0])      # add new intervales 
                        # print ("its=",its)
                        # break
                    pj+=1
                pi+=1
                
                r +=checked_its 

        # print ("r=",its)
        return its

s = Solution()
s.merge([[1,3],[2,16],[8,10],[15,18]])    # [[1,18]]

"""Share
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.
"""

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        ls = []
        dic = {")": "(", "}": "{", "]": "["}
        top = "0"
        
        for p in s:
            
            if p in dic.keys(): # closing bracket
                if len(ls) > 0:
                    top = ls.pop() # open bracket                   
                if dic[p] != top:
                    return False   #not find pair                
            else:
                ls.append(p)
                       
        if len (ls) >0:
            return False
        
        return True


"""#346. Moving Average from Data Stream

Share
Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

Example:

MovingAverage m = new MovingAverage(3);
m.next(1) = 1
m.next(10) = (1 + 10) / 2
m.next(3) = (1 + 10 + 3) / 3
m.next(5) = (10 + 3 + 5) / 3
"""

class MovingAverage(object):

    def __init__(self, size):
        """
        Initialize your data structure here.
        :type size: int
        """
        self.maxSize = size  # actual number of ele
        self.eles = []
        self.sum = 0.0
        

    def next(self, val):
        """
        :type val: int
        :rtype: float
        """        
          
        self.eles.append(val)                
        if len (self.eles) > self.maxSize: 
            self.sum  =  self.sum -self.eles[0]
            self.eles.remove(self.eles[0])   
            
        self.sum = self.sum  + val
        
        return self.sum/len (self.eles)

"""*341*. Flatten Nested List Iterator

Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:

Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, 
             the order of elements returned by next should be: [1,1,2,1,1].
"""

# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class NestedIterator(object):

    def __init__(self, nestedList):
        """
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        """
        self.queue = collections.deque()  # constuct an empty string
        
        def getAll(nests):
            for nest in nests:
                if nest.isInteger():
                    self.queue.append (nest.getInteger())
                else:
                    getAll(nest.getList())
        getAll(nestedList)
            

    def next(self):
        """
        :rtype: int
        """
        return self.queue.popleft()
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return len(self.queue)

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())

"""1041. Robot Bounded In Circle (Medium)
Favorite

Share
On an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:

"G": go straight 1 unit;
"L": turn 90 degrees to the left;
"R": turn 90 degress to the right.
The robot performs the instructions given in order, and repeats them forever.

Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.
"""

class Solution(object):
    def isRobotBounded(self, instructions):
        """
        :type instructions: str
        :rtype: bool
        """
    
    
        x = 0
        y = 0
        d = "N"

        d_l_loop = ["N","W","S","E","N"]
        d_r_loop = d_l_loop[::-1]
        print (d_r_loop)
        for i in instructions:
            if i == "G":
                if d == "N":
                    y +=1
                elif d == "S":
                    y -=1
                elif d == "W":
                    x -= 1
                else:
                    x +=1
            elif i == "L":
                d = d_l_loop[d_l_loop.index(d)+1]
            else:
                d = d_r_loop[d_r_loop.index(d)+1]
            print (i,"(" , x,",",y,")", "next d:",d)

        if d !="N" or (x==0 and y==0):
            return True
        else:
            return False

class Solution(object):
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """

        res = []
        q =collections.deque() # storage the id
        for i in range (len(nums)):
            if len(q)>0 and q[0] == i-k:
                q.pop()
            print (q)
            while len(q)>0  and nums[q[-1]] < nums[i]:
                q.popleft()
                
            q.append(i)
            print (i,q)
            if i>=k -1:
                res.append (nums[q[0]])
        return res

"""#486. Predict the Winner

Share
Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.

Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.

Example 2:
Input: [1, 5, 233, 7]
Output: True
Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
"""

'''
   [1, 5, 23, 7]              winA         win B 
    a              [5,23,7]   
       b           [23,7]                 5 -23 = -18
           a       [5]        23 - 5=18
              b    [23]                   7-23 = 


'''
 
def getscore(arr, first, end):
    if first == end:
        return arr[first]
    else:
        # how much score it earn 
        return max( arr[first] - getscore(arr, first + 1, end)  ,
                    arr[end]   - getscore(arr, first , end-1) )     
def ifwin(arr):
    return getscore(arr,0,len(arr)-1) >=0
ifwin( [1, 5, 233, 7])

"""#529. Minesweeper

https://leetcode.com/problems/minesweeper/
"""

''' SOlution1  DFS'''
class Solution(object):
    
    def check_range(self,i,j):
        if i >=0 and i < len(self.board) and j >=0 and j < len(self.board[0]):
            return True
        else:
            return False
    
    def check_adjacent_mines(self,i,j):
        num_of_mines= 0
        # COUNT NUMBER OF MINES
        for dir in self.dirs:
            pi,pj = i+dir[0],j+ dir[1]
            if self.check_range(pi,pj) :
                if self.board[pi][pj] == "M":
                    num_of_mines+=1
                                     
        return num_of_mines      
    
    def updateBoard(self, board, click):
        """
        :type board: List[List[str]]
        :type click: List[int]
        :rtype: List[List[str]]
        """      
        self.board=board        
        self.dirs = [ [-1,1],[0,1],[1,1],[-1,0],[1,0],[-1,-1],[0,-1],[1,-1]]
        stop_tag= False                 

        if stop_tag is False:
            if self.check_range(click[0],click[1]):
            #If a mine ('M') is revealed, then the game is over - change it to 'X'.
                if board[click[0]][click[1]]=="M":
                    board[click[0]][click[1]]="X"
                    stop_tag = True
                    return board                
                
                elif  board[click[0]][click[1]]=="E" :
                    numofmines_adj = self.check_adjacent_mines(click[0],click[1])

                    if    numofmines_adj==0 :
                        board[click[0]][click[1]]="B"
                        for dir in self.dirs:
                            pi,pj = click[0]+dir[0],click[1]+ dir[1]
                            self.updateBoard( board, [pi,pj])
                
                    else:#numofmines_adj>0 ):
                        board[click[0]][click[1]]= str(numofmines_adj)
                    
                    stop_tag= True    

        return board